<join>
: 일반적으로 PK와 FK 값의 연관성에 의해 성립된다.
: DBMS 옵티마이저는 From 절에 나열된 테이블이 아무리 많아도 항상 2개의 테이블씩 짝을 지어 join을 수행한다.
: EQUI join은 join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
: EQUI join은 '=' 연산자에 의해서만 수행되며, 그 이외에 비교연산자를 사용하는 경우에는 모두 Non EQUI join이다.
: 대부분 Non EQUI join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.


<ROLE (과목2-121번)>
: ROLE은 많은 DBMS사용자에게 개별적으로 많은 권하을 부여하는 번거로움과 어려움을 해소하기 위해
다양한 권한을 하나의 그룹으로 묶어놓은 논리적인 권한의 그룹이다.
다양한 권한을 그룹으로 묶어 관리할 수 있도록 사용자와 권한 사이에서 중개 역할을 수행한다.
이러한 ROLE을 DBMS USER에게 부여하기 위해서는 GRANT 명령을 사용하며,
ROLE을 회수하기 위해서는 REVOKE 명령을 사용한다.


<Trigger (트리거) (과목2)>
: commit rollback 등 TCL 사용 불가능
: 데이터베이스에 로그인하는 작업에도 정의할 수 있다.


<실행계획 정보의 구성요소 (과목2)>
: 조인 기법, 최적화 정보, 액세스 기법, 연산


<NL, Sort Merge, Hash Join (과목2)>
1. NL Join
- 결과 행의 수가 적은(처리 주관 범위가 좁은) 테이블을 조인 순서상 선행 테이블로 선택하는 것이 전체 일량을 줄일 수 있다.
- NL Join은 랜덤 방식으로 데이터를 액세스하기 때문에 처리 범위가 좁은 것이 유리하다. 

2. Sort Merge Join
- Hash Join과는 달리 동등 조인 뿐만 아니라 비동등 조인에 대해서도 조인 작업이 가능하다.
- 조인 칼럼의 인덱스를 사용하지 않기 때문에 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 조인 기법이다.

3. Hash Join
- 조인 칼럼의 인덱스를 사용하지 않기 때문에 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 조인 기법이다.
- 해쉬 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인 즉, 동등 조인에서만 사용할 수 있다.
- 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다. 


<INDEX (과목2)>
1. B-트리(Balance Tree) 인덱스
- DBMS에서 가장 일반적인 인덱스는 B-트리 인덱스이다. 
- 브랜치 블록(Branch Block)과 리프 블록(Leaf Block)으로 구성된다.
- 브랜치 블록은 분기를 목적으로 하고 리프블록은 인덱스를 구성하는 컬럼의 값으로 정렬된다.
- 일반적으로 OLTP 시스템 환경에서 가장 많이 사용된다.

2. CLUSTERED 인덱스
- 리프 페이지가 곧 데이터 페이지이다.
- 리프 페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적으로 정렬되어 저장된다.

3. BITMAP 인덱스
- 시스템에서 사용될 질의를 시스템 구현 시에 모두 알 수 없는 경우인 DW 및 AD-HOC 질의 환경을 위해서 설계되었다.
- 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조이다.

4. 기본 인덱스(Primary Key): unique & not null => 중복이나 널값 불가능!!

5. 보조 인덱스 : unique 인덱스가 아니라면 중복 데이터 입력 가능